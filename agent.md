# Agent.md: AI Agent Instructions for Building X Articles to PDF Exporter Browser Extension

## Overview
This document serves as a comprehensive guide for an AI agent (e.g., an autonomous developer powered by LLMs) to build, test, and deploy the "X Articles Exporter" browser extension based on the provided Product Requirements Document (PRD). The goal is to create a lightweight, privacy-focused Chrome extension (Manifest V3 compliant) that injects an "Export to PDF" button on X (Twitter) Article pages, scrapes the content, generates a professional PDF with a specific structure, and downloads it locally for offline use.

The agent should follow these instructions step-by-step, using the specified tech stack (Plasmo framework, jsPDF, etc.). Assume access to a development environment with Node.js, Git, and browser testing tools. If any clarifications or additional tools are needed (e.g., code execution for testing snippets), query the user or use integrated tools.

The user will create the project directory themselves, and the working directory is the current directory. Use pnpm as the package manager throughout. Use TypeScript for all code (e.g., .ts/.tsx files). A sample HTML will be provided by the user to reference the structure of an X Article post for accurate DOM scraping—use this to identify selectors like classes for title, author, body, headings, etc.

### Key Principles
- **Simplicity**: Keep the code "stupid simple" – minimal features, clean architecture.
- **Privacy**: All operations local; no external servers or tracking.
- **Professionalism**: PDFs must be high-quality, with clickable TOC and preserved formatting.
- **Target Users**: Focus on offline access needs (e.g., users in Lagos with spotty internet).
- **Compliance**: Adhere to Manifest V3, X's ToS (user-initiated only), and best practices for extensions.
- **Iteration**: Build MVP first; test thoroughly; suggest enhancements only after core is done.

## Tech Stack
- **Framework**: Plasmo (for easy extension scaffolding, content scripts, popups, and bundling). Install via `pnpm create plasmo`.
- **Languages**: TypeScript (with .ts/.tsx files; Plasmo supports it natively).
- **Libraries**:
  - jsPDF: For PDF generation (include AutoTable for TOC and structures).
  - DOMPurify: For sanitizing scraped HTML.
- **Browser APIs**: Use `chrome.scripting`, `chrome.downloads`, `chrome.storage`, MutationObserver.
- **Build Tools**: Plasmo's built-in (Parcel/Vite); ESLint for linting.
- **Testing**: Jest (via Plasmo); manual testing on real X Articles.
- **Version Control**: Git; commit often with descriptive messages.
- **Deployment**: Chrome Web Store; GitHub repo for open-sourcing.

## Step-by-Step Build Plan

### Step 1: Project Setup
1. Assuming the user has created the directory and is in the current working directory, initialize Plasmo: `pnpm create plasmo .` (select Chrome as target, TypeScript).
2. Install dependencies:
   ```
   pnpm add jspdf jspdf-autotable dompurify
   pnpm add -D @types/jspdf @types/dompurify # For TypeScript types if available
   ```
3. Set up Git: `git init; git add .; git commit -m "Initial Plasmo setup"`.
4. Configure `manifest.json` (auto-generated by Plasmo, but verify):
   - Version: "1.0.0".
   - Permissions: `["activeTab", "storage", "downloads"]`.
   - Content scripts: Match `https://x.com/*/status/*` (for Article URLs).
   - Icons: Add simple icons (e.g., PDF symbol).

5. Reference the user-provided sample HTML: ./reference.html.

### Step 2: Implement Detection and Button Injection (Content Script)
1. In `content.ts` (Plasmo's content script file):
   - Use MutationObserver to watch for page loads/mutations.
   - Detect if it's an Article: Check URL pattern (`location.pathname.includes('/status/')`), then DOM for indicators (e.g., presence of long-form content classes like `.article-container`, `.longform`, or indicators such as "Article" tag/text, content length > certain threshold, or rich formatting elements—cross-reference with sample HTML).
   - If detected, inject button:
     ```typescript
     const button = document.createElement('button');
     button.textContent = 'Export to PDF';
     button.style.position = 'fixed';
     button.style.top = '10px';
     button.style.right = '10px';
     button.style.background = '#1DA1F2';
     button.style.color = 'white';
     button.style.border = 'none';
     button.style.padding = '8px 16px';
     button.style.cursor = 'pointer';
     button.onclick = exportToPDF;
     document.body.appendChild(button); // Or append near header
     ```
   - Add keyboard shortcut listener if enabled in settings.

2. Handle edge cases: Disable button if not an Article; log errors locally.

3. Test: Load extension in Chrome (via `pnpm dev`), visit a sample Article URL (e.g., https://x.com/thedankoe/status/2010042119121957316), verify button appears.

### Step 3: Content Scraping
1. In the `exportToPDF` function (in content.ts):
   - Extract metadata using selectors from sample HTML:
     ```typescript
     const title = document.querySelector('h1.article-title')?.textContent || 'Untitled Article'; // Adjust based on sample HTML
     const author = document.querySelector('.author-handle')?.textContent;
     const date = document.querySelector('.publish-date')?.textContent;
     const url = window.location.href;
     ```
   - Scrape body:
     - Use `document.querySelector('.article-body')` to get main content (adjust per sample).
     - Traverse children: Collect headings (for TOC), paragraphs, lists, images (src to base64 via canvas if needed), links.
     - Sanitize with DOMPurify: `DOMPurify.sanitize(htmlContent)`.
   - Store headings for TOC: Array of {text: string, level: number}.

2. Use settings from `chrome.storage.sync.get` (e.g., includeImages).

3. Test: Console.log scraped data on button click; verify on real Articles and sample HTML.

### Step 4: PDF Generation
1. Import jsPDF in content.ts:
   ```typescript
   import jsPDF from 'jspdf';
   import 'jspdf-autotable';
   ```
2. In `exportToPDF`:
   - Create doc: `const doc = new jsPDF();`
   - **Title Page**:
     ```typescript
     doc.setFontSize(24);
     doc.text(title, 105, 50, { align: 'center' });
     doc.setFontSize(12);
     doc.text(`By: ${author ?? 'Unknown'}`, 105, 70, { align: 'center' });
     doc.text(`Published: ${date ?? 'Unknown'}`, 105, 80, { align: 'center' });
     doc.text(url, 105, 90, { align: 'center' }); // Make clickable: doc.textWithLink(url, ...)
     doc.addPage();
     ```
   - **TOC Page**:
     - Use AutoTable: Generate table with headings, add internal links (via jsPDF's addLink).
     - Example:
       ```typescript
       const tocData = headings.map(h => [h.text]);
       doc.autoTable({ head: [['Table of Contents']], body: tocData });
       // Add links: For each entry, doc.addLink(x, y, w, h, { pageNumber: h.page });
       doc.addPage();
       ```
   - **Body Pages**:
     - Iterate scraped content: `doc.text(paragraph, x, y);` for text; `doc.addImage(imgData, 'JPEG', x, y, w, h);` for images.
     - Handle formatting: Set font styles for bold/italic; lists as bulleted text.
     - Page breaks: Use `doc.addPage()` when y exceeds margin.
   - Apply theme (light/dark): Adjust text color/fill.
   - Filename: `${title.replace(/\s/g, '_')}_by_${author ?? 'Unknown'}.pdf`.

3. Download: `doc.save(filename);` (uses chrome.downloads implicitly via jsPDF).

4. Test: Generate PDFs from sample HTML and real Articles; check structure, clicks, offline view in Adobe Reader.

### Step 5: Settings Popup
1. In `popup.tsx` (Plasmo's popup file):
   - Use simple React form: Checkboxes for includeImages, theme select (light/dark), page size.
   - Save to `chrome.storage.sync.set`.
   - Onboarding: Display welcome message on first load.

2. Test: Click extension icon; toggle settings; verify they affect exports.

### Step 6: Error Handling and Polish
1. Add try-catch in export function: Show alert/toast on failures (e.g., "Failed to export – refresh page").
2. Accessibility: Add ARIA to button; tag PDF elements (jsPDF supports basic).
3. Performance: Optimize for long Articles (chunk processing).
4. Internationalization: English only for MVP.

### Step 7: Testing and QA
1. Unit Tests: Use Jest for scraping/PDF funcs (e.g., mock DOM).
2. Manual: Test on 5+ real Articles (various lengths, with/without images); check Lagos-specific (e.g., mobile view).
3. Edge Cases: Paywalled, deleted posts, non-Articles (button hidden).
4. Metrics: Log export times locally.

### Step 8: Deployment
1. Build: `pnpm build`.
2. Zip and submit to Chrome Web Store: Include description from PRD, screenshots.
3. Open-source: Push to GitHub; add README with install guide.
4. Post-Deploy: Monitor reviews; update for X changes.

## Potential Challenges & Mitigations
- X DOM Changes: Use flexible selectors based on sample HTML; plan for v1.1 updates.
- jsPDF Limits: For very long Articles, split PDFs or warn user.
- Permissions: Test incognito mode.
- If Stuck: Use code execution tools to test snippets; browse docs for jsPDF/Plasmo.

## Completion Criteria
- Extension installs/loads in Chrome.
- Button injects on Article pages only.
- PDFs generate with exact structure (title page, clickable TOC, body).
- Offline downloads work; no errors on standard use.
- Code clean, committed, and deployable.

Once built, provide the GitHub repo link or zip file to the user for review. If enhancements needed, iterate based on feedback.